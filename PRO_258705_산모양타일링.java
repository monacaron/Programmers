/*
 * 한 변의 길이가 1인 정삼각형 2n + 1개를 이어붙여 윗변의 길이가 n, 아랫변의 길이가 n + 1인 사다리꼴 만들 수 있음
 * 이때 사다리꼴의 윗변과 변을 공유하는 n개의 정삼각형 중 일부의 위쪽에 같은 크기의 정삼각형을 붙여 새로운 모양 만들기
 * 이렇게 만든 모양을 정삼각형 or 마름모 타일로 빈 곳 없이 채우는 경우의 수
 
 * dp
 * 이전 끝 부분이 삼각형 or 마름모 ?
 * \/ | \_\ | _/\ | /\/\
 * 이전 모양에서 연장 가능한 xxx형으로 연장 가능한 경우의 수
 * dp[n][0] : 마지막이 삼각형으로 채워진 모양
 * dp[n][1] : 마지막이 마름모로 채워진 모양
 * 삼각형으로 끝나는 사다리꼴) dp[n][0] = dp[n - 1][0] * 2 + dp[n - 1][1]
 * 삼각형 * (올삼각형 + 마름모삼각형) + 마름모 * 올삼각형
 * 삼각형으로 끝나는 정삼각형) dp[n][1] = dp[n - 1][0] * 3 + dp[n - 1][1] * 2
 * 삼각형 * (올삼각형 + 왼마름모삼각형 + 윗마름모삼각형) + 마름모 * (올삼각형 + 윗마름모삼각형)
 
 * 마름모로 끝나는 사다리꼴) dp[n][0] = dp[n - 1][0] + dp[n - 1][1]
 * 마름모로 끝나는 정삼각형) dp[n][1] = dp[n - 1][0] + dp[n - 1][1]
 * 마름모로 마무리 되는 경우) 이전 모양과 상관없이 1가지 경우만 나옴
 * 예제의 4번째 모양과 같이 마름모 바로 앞에 무엇이 붙든 정삼각형을 얹은 마름모만 가능
 */

class Solution {
    static final int MOD = 10007;
    public int solution(int n, int[] tops) {
        int[][] dp = new int[n + 1][2]; // 삼각형끝(0), 마름모끝(1)
        
        if(tops[0] == 0) { // 첫 모양이 사다리꼴인 경우
            dp[1][0] = 2;
        } else {
            dp[1][0] = 3; // 첫 모양이 정삼각형인 경우
        }
        dp[1][1] = 1; // 상관없이 1개 나옴
        
        for (int i = 2; i <= n; i++) {
            if (tops[i - 1] == 0) {
                dp[i][0] = dp[i - 1][0] * 2 + dp[i - 1][1];
                dp[i][1] = dp[i - 1][0] + dp[i - 1][1];
            } else {
                dp[i][0] = dp[i - 1][0] * 3 + dp[i - 1][1] * 2;
                dp[i][1] = dp[i - 1][0] + dp[i - 1][1];
            }
            
            dp[i][0] %= MOD;
            dp[i][1] %= MOD;
        }
        
        return (dp[n][0] + dp[n][1]) % MOD;
    }
}
